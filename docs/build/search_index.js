var documenterSearchIndex = {"docs":
[{"location":"CalcoloConfini.html#Calcolo-dei-confini","page":"Calcolo dei confini","title":"Calcolo dei confini","text":"","category":"section"},{"location":"CalcoloConfini.html","page":"Calcolo dei confini","title":"Calcolo dei confini","text":"Nella maggior parte dei casi, l'ambiente di calcolo geometrico di   destinazione è in grado di visualizzare, più in generale di gestire, un   modello solido utilizzando solamente una rappresentazione dei   confini/bordi, tipicamente usando una triangolazione. È facile ottenere   una tale rappresentazione moltiplicando la matrice dell'operatore   3-boundary (bordi a tre dimensioni) delta_3  C_3 longmapsto   C_2^circlearrowleft per il vettore di coordinate C3 nello spazio   dell'espressione solida, calcolato come termine binario nel nostro   insieme algebrico[1].\nUna volta ottenuta in questo modo la coordinata designata del vettore di   bordo dell'oggetto solido, cioè la 2-catena formata dalle sue 2-celle   orientate (le facce), queste devono essere raccolte da colonne in una   \"matrice facciale\" sparsa e tradotta nella corrispondente matrice di   1-cicli orientati di spigoli/edge, per moltiplicazioni destre di   [delta_2] per la matrice delle facce. I poligoni di   confine/boundary generati (corrispondenti alle colonne della matrice   prodotto sparsa) saranno normalmente triangolizzati e infine   renderizzati dall'hardware grafico o esportati in formati di file   grafici standard o qualsiasi altro formato geometrico necessario per   l'applicazione prevista.\n\nDefinizione Complessi Geometrici LAR: è utile ricordare che per   mostrare una triangolarizzazione di facce di bordo nella loro propria   posizione nello spazio, tutte le informazioni geometriche e topologiche   necessarie sono contenute all'interno di evaluatedLAR o in   GeometricComplex (GC), data la coppia :","category":"page"},{"location":"CalcoloConfini.html","page":"Calcolo dei confini","title":"Calcolo dei confini","text":"mu  C_0 longmapsto E^3 (delta_2delta_1 delta_0)  \nequiv V (CF FE EV)","category":"page"},{"location":"CalcoloConfini.html","page":"Calcolo dei confini","title":"Calcolo dei confini","text":"dove V è di tipo Matrix-Real con tre righe e colonne pari alla   cardinalità di C_0 ed inoltre (CF, FE, EV) sono matrici sparse di   co-bordi (coboundary). Le coppie ordinate di lettere da V, E, F, C,   corrispondono alla sequenza coboundary che segue: Vertici → Bordo (edge)   → Facce → Celle espresso attraverso l'ordine sinistrorso Colonna → Riga   di mappe matriciali di operatori.\n\nMemorizzazione di Complessi Geometrici Lar: La topologia di un   3-complesso LAR è completamente rappresentata dagli operatori   (delta_2,delta_1, delta_0) , cioè dagli array sparsi (CF FE EV), fornendo le incidenze tra vertici, bordi e facce, sia per b-reps  (rappresentazione geometrica dai bordi) che per rappresentazioni cellulari.","category":"page"},{"location":"CalcoloConfini.html","page":"Calcolo dei confini","title":"Calcolo dei confini","text":"[1]: Si ricordi che con la notazione C si intende il complesso di catene nel campo binario 1,0 e con C^circlearrowleft si indica il complesso di catene orientato all'interno del campo ternario 0,1,-1 in modo da avere confini orientati. Quindi le matrici di confine generate da TGW sono mappe C_3 longmapsto C_2^circlearrowleft.","category":"page"},{"location":"ComplCelle.html#Complessi-di-celle","page":"Complessi di celle","title":"Complessi di celle","text":"","category":"section"},{"location":"ComplCelle.html","page":"Complessi di celle","title":"Complessi di celle","text":"Definizione d - Manifold : un manifold è uno spazio topologico   che localmente è simile ad un altro spazio topologico ben conosciuto, ad   esempio lo spazio euclideo n-dimensionale, ma che globalmente può avere   proprietà geometriche differenti, ad esempio può essere \"curvo\"   contrariamente allo spazio euclideo. Ogni punto di un manifold con d   dimensioni ha un vicino che è omeomorfo, cioè simile ma non   obbligatoriamente uguale del tutto, ad E^3, lo spazio euclidiano di   d-dimensioni.\n\nDefinizione Cella : una p-cella è un p-manifold con   confini 0 leq p leq d i quali sono lineari a tratti, connessi,   possibilmente non convessi e non contrattabili, non si storcono. Questa   definizione si riferisce ai complessi cellulari di questo lavoro e nella   nostra rappresentazione ci possono essere celle con buchi interni.\nAvremo a che fare con celle Piecewise-Linear (PL) (lineari a tratti)   rispettivamente di dimensione 0, 1, 2 e 3. Va notato che le 2-celle e   3-celle possono contenere dei fori (buchi), pur rimanendo collegati. In   altre parole, le celle sono poliedri, cioè segmenti, poligoni e poliedri   incorporati in uno spazio bi o tridimensionale.\n\nDefinizione complesso cellulare: un p-complesso cellulare è un   insieme finito di celle che hanno al massimo dimensione p, insieme   alle loro facce r-dimensionali dei bordi con 0 leq r leq p. Una   faccia è un elemento del confine lineare a tratti della cella, il quale   soddisfa le condizioni di compatibilità di confine, che seguono:","category":"page"},{"location":"ComplCelle.html","page":"Complessi di celle","title":"Complessi di celle","text":"Due p-celle sono boundary-compatible quando i loro punti di   intersezione contengono le stesse r-facce.\n\nUn complesso cellulare di dimensione p è definito regolare quando   ogni r-cella, con 0\\leq r\\leqp , è una faccia di una p-cella\n\nDefinizione Skeleton: Un s-skeleton di un p-complesso Lambda_p,   con s leq p, è l'insieme Lambda_s di tutte le r-celle di Lambda_p. Ogni scheletro di un complesso regolare è un sottocomplesso regolare.\n\nDefinizione Rappresentazione Geometrica: La rappresentazione   algebrica lineare (LAR) ha introdotto l'uso di array binari sparsi per   calcolare e rappresentare una topologia algebrica di complessi   cellulari, ovvero spazi lineari di catene e operatori di (co)confine   lineari. (Quindi è una mappatura della disposizione geometrica con   matrici/array sparsi binari).\n\nDefinizione Spazio di supporto: Lo spazio di supporto   |Lambda| di un complesso cellulare è l'insieme dei punti dell'unione   delle proprie celle.\nUna p-catena può essere vista, forzando il linguaggio, come   una collezione di p-celle.","category":"page"},{"location":"analisi.html#Prestazioni","page":"Ottimizzazione","title":"Prestazioni","text":"","category":"section"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Con l'aiuto della libreria Profile è possibile visualizzare a schermo un riferimento grafico relativo ai tempi di esecuzione.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"L'asse orizzontale, nel grafico prodotto, rappresenta la quantità di tempo (più precisamente, il numero di backtraces)  speso su ogni riga, è quindi sensato focalizzare l'attenzione sulle righe relative alle barre più lunghe.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Di seguito il grafico prodotto da Profile per il metodo spatial_arrangement.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: Prestazioni di spatial_arrangement)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Si vede come la riga più in basso, quindi anche quella in cui il  processo rimane fermo più tempo è relativa a spatial_arrangement_1.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Applichiamo quindi Profile a spatial_arrangement_1 ottenendo il seguente grafico.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: Prestazioni di spatial_arrangement_1)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Il metodo spatial_arrangement_1 presenta già una parallelizzazione che sfrutta un numero di Threads superiore ad 1. ","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"La funzione su cui focalizzarsi risulta essere quindi frag_face.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Nel notebook  fragfaceparallelized.ipynb ci occuppiamo quindi di migliorare le prestazioni di questo metodo con un risultato di riduzione spaziale e temporale di quasi il 20%, come mostrato dai seguenti benchmarks.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"V, EV, FE = get_input()\n@benchmark Lar.Arrangement.frag_face(Lar.Points(V),EV,FE,[2,3,4,5],2)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: frag_face)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"V, EV, FE = get_input()\n@benchmark frag_face_async(Lar.Points(V),EV,FE,[2,3,4,5],2)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: frag_face_async)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"La parallelizzazione prosegue nel notebook mergeverticesparallelized.ipynb con i miglioramenti evidenziati dai successivi benchmarks.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"V, EV, FE = get_input()\n@benchmark Lar.Arrangement.merge_vertices($Lar.Points(V),$Lar.ChainOp(EV),$Lar.ChainOp(FE),$1e-8)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: merge_vertices)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"V, EV, FE = get_input()\n@benchmark merge_vertices_async(Lar.Points(V),Lar.ChainOp(EV),Lar.ChainOp(FE),1e-8)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: merge_vertices_async)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Inserendo le funzioni parallelizzate nel metodo spatial_arrangement_1, i risultati diventano significativi, come mostrato dalle seguenti figure.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"spatialarrangement1.ipynb","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"V, EV, FE = get_input()\n@benchmark Lar.Arrangement.spatial_arrangement_1(Lar.Points(V),Lar.ChainOp(EV),Lar.ChainOp(FE),false)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: spatial_arrangement_1_bench)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"V, EV, FE = get_input()\n@benchmark spatial_arrangement_1_rev(Lar.Points(V),Lar.ChainOp(EV),Lar.ChainOp(FE)) ","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: spatial_arrangement_1_rev)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Il tempo di esecuzione si riduce quindi del 75%, mentre la memoria allocata di quasi il 60%.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"Infine testiamo l'intero processo spatial_arrangement ottenendo i seguenti miglioramenti.","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"spatial_arrangement.ipynb","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"@benchmark Lar.Arrangement.spatial_arrangement(W, cop_EV, cop_FE)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: spatial_arr)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"@benchmark TGW.spatial_arrangement(W, cop_EV, cop_FE)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"(Image: spatial_arr_rev)","category":"page"},{"location":"analisi.html","page":"Ottimizzazione","title":"Ottimizzazione","text":"L'esecuzione dell'algoritmo TGW3D risulta essere quindi ridotta di un fattore circa 4, sia per quanto riguarda la memoria che il tempo utilizzati.","category":"page"},{"location":"docs_spatial_arrangement.html","page":"Documentazione","title":"Documentazione","text":"TopologicalGiftWrapping8A.frag_face_channel","category":"page"},{"location":"docs_spatial_arrangement.html#TopologicalGiftWrapping8A.frag_face_channel","page":"Documentazione","title":"TopologicalGiftWrapping8A.frag_face_channel","text":"frag_face_channel(in_chan, out_chan, V, EV, FE, sp_idx)\n\nParallel fragmentation of faces in FE against faces in sp_idx.\n\n\n\n\n\n","category":"function"},{"location":"docs_spatial_arrangement.html","page":"Documentazione","title":"Documentazione","text":"TopologicalGiftWrapping8A.frag_face","category":"page"},{"location":"docs_spatial_arrangement.html#TopologicalGiftWrapping8A.frag_face","page":"Documentazione","title":"TopologicalGiftWrapping8A.frag_face","text":"frag_face(V::Points, copEV::ChainOp, copFE::ChainOp; [multiproc::Bool])\n\nPerforms the 2D transformation of the faces provided as input via the sigma parameter and finally each face in this sigma parameter intersects with the faces in sp index\n\n\n\n\n\n","category":"function"},{"location":"docs_spatial_arrangement.html","page":"Documentazione","title":"Documentazione","text":"TopologicalGiftWrapping8A.merge_vertices","category":"page"},{"location":"docs_spatial_arrangement.html#TopologicalGiftWrapping8A.merge_vertices","page":"Documentazione","title":"TopologicalGiftWrapping8A.merge_vertices","text":"merge_vertices(V::Lar.Points, EV::Lar.ChainOp, FE::Lar.ChainOp, err::Float64)\n\nPerforms merge of neighboring faces, vertices and sides\n\nAdditional arguments:\n\nerr::Float64: Hyperparameter. Defaults to 1e-4.\n\n\n\n\n\n","category":"function"},{"location":"docs_spatial_arrangement.html","page":"Documentazione","title":"Documentazione","text":"TopologicalGiftWrapping8A.spatial_arrangement_1","category":"page"},{"location":"docs_spatial_arrangement.html#TopologicalGiftWrapping8A.spatial_arrangement_1","page":"Documentazione","title":"TopologicalGiftWrapping8A.spatial_arrangement_1","text":"spatial_arrangement_1(V::Points, copEV::ChainOp, copFE::ChainOp; [multiproc::Bool])\n\nFirst step of spatial arrangement. It computes and fragments the faces in order to recall planar arrangement.\n\nAdditional arguments:\n\nmultiproc::Bool: Runs the computation in parallel mode. Defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"docs_spatial_arrangement.html","page":"Documentazione","title":"Documentazione","text":"TopologicalGiftWrapping8A.removeinnerloops","category":"page"},{"location":"docs_spatial_arrangement.html#TopologicalGiftWrapping8A.removeinnerloops","page":"Documentazione","title":"TopologicalGiftWrapping8A.removeinnerloops","text":"removeinnerloops(g, nFE)\n\nRemove the faces within the inner loops from sparse matrix nFE. The return walue has g less rows than the input nFE.\n\n\n\n\n\n","category":"function"},{"location":"docs_spatial_arrangement.html","page":"Documentazione","title":"Documentazione","text":"TopologicalGiftWrapping8A.spatial_arrangement","category":"page"},{"location":"docs_spatial_arrangement.html#TopologicalGiftWrapping8A.spatial_arrangement","page":"Documentazione","title":"TopologicalGiftWrapping8A.spatial_arrangement","text":"spatial_arrangement(V::Points, copEV::ChainOp, copFE::ChainOp; [multiproc::Bool])\n\nCompute the arrangement on the given cellular complex 2-skeleton in 3D.\n\nA cellular complex is arranged when the intersection of every possible pair of cell of the complex is empty and the union of all the cells is the whole Euclidean space. The function returns the full arranged complex as a list of vertices V and a chain of borders EV, FE, CF.\n\nAdditional arguments:\n\nmultiproc::Bool: Runs the computation in parallel mode. Defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"AlgTGW.html#Algoritmo-Topological-Gift-Wrapping-TGW","page":"Algoritmo Topological Gift Wrapping - TGW","title":"Algoritmo Topological Gift Wrapping - TGW","text":"","category":"section"},{"location":"AlgTGW.html","page":"Algoritmo Topological Gift Wrapping - TGW","title":"Algoritmo Topological Gift Wrapping - TGW","text":"L'algoritmo TGW è descritto in questa sezione, generalizzandolo per lo  spazio d-dimensionale. L'input è la matrice sparsa [delta_d-1],   l'output è la matrice [delta_d^+], dalla d-catena al (d-1)-ciclo   orientato.","category":"page"},{"location":"AlgTGW.html","page":"Algoritmo Topological Gift Wrapping - TGW","title":"Algoritmo Topological Gift Wrapping - TGW","text":"(Image: image)","category":"page"},{"location":"funzioni.html#Funzioni-del-progetto","page":"Analisi","title":"Funzioni del progetto","text":"","category":"section"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"Dopo un'attenta analisi del repository https://github.com/cvdlab/LinearAlgebraicRepresentation.jl, abbiamo   definito il grafo delle dipendenze relativo al progetto a noi assegnato. ","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"Il risultato della nostra analisi è la seguente:","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"(Image: image)","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"Si definiranno ora le funzionalità principali della repository utili ai   fini dell'algoritmo TGW 3D.","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"La funzione spatial arrangement si occupa di partizionare i complessi  cellulari, presi in input, con scheletro di dimensione 2 in 3D. ","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"Ne segue  che un complesso cellulare è partizionato quando l'intersezione di  ogni possibile coppia del complesso risulta vuota e l'unione di tutte le celle è tutto lo spazio euclideo. ","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"L'output della funzione consiste nella partizione complessa rappresentata da una lista di   vertici V e di una catena di bordi EV, FE, CF.","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"spatial_arrangment_1 frammenta le facce delle figure ai fini dell'utilizzo del arrangment planare. A tal fine usa come funzioni di supporto frag face e merge vertices. Saranno proprio questi i metodi che andremmo ad ottimizare.\n","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"frag_face: effettua la trasformazione in 2D delle facce fornite in input tramite il parametro sigma ed infine ogni faccia di questo parametro sigma si interseca con le facce in sp index.","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"merge_vertices: effettua il merge delle facce vicine, vertici e lati. ","category":"page"},{"location":"funzioni.html","page":"Analisi","title":"Analisi","text":"spatial_arrangment_2: ricostruisce le facce dei poligoni permettendo il wrapping in 3D.","category":"page"},{"location":"CatEDisp.html#Catene-e-Disposizioni","page":"Catene e Disposizioni","title":"Catene e Disposizioni","text":"","category":"section"},{"location":"CatEDisp.html","page":"Catene e Disposizioni","title":"Catene e Disposizioni","text":"La parola arrangment è usata nella geometria combinatoria e   computazionale, ma anche nella topologia, come sinonimo di partizione   spaziale.\n\nDefinizione Space Arrangement: Data una collezione finita S di   oggetti geometrici in E^d la disposizione A(S) è la decomposizione   di E^d in celle connesse di dimensione 0 1d indotte da S.   Siamo interessati alla partizione dello spazio euclideo indotta da una   collezione di complessi cellulari PL.\nData una collezione S di oggetti geometrici, un nuovo metodo per   calcolare la topologia della loro disposizione spaziale consiste nel   valutare A(S) come complesso di catene C.\nEsempio di 3D arrangment\n","category":"page"},{"location":"CatEDisp.html","page":"Catene e Disposizioni","title":"Catene e Disposizioni","text":"(Image: image) (Image: image)","category":"page"},{"location":"CatEDisp.html","page":"Catene e Disposizioni","title":"Catene e Disposizioni","text":"Nelle figure si mostra la disposizione A(S) generata dalla collezione   S fatta dalle trenta facce 2D di 5 cubi che si intersecano   randomicamente. Ogni cella 3D in A(S) è generata da una colonna   della matrice sparsa della mappa di confine confine delta_3 con   valori in (01-1). Nella figura a sinistra si nota la collezione S di   5 cubi randomici in E^3, mentre quella di destra mostra le 3-celle   generate in E^3 dalla disposizione A(S), (non in scala, e   opportunamente ruotate per mostrare meglio la loro forma complessa). Si   noti che alcune celle contengono buchi. Le colonne di delta_3 sono 2-cicli, cioè catene chiuse in C2. In   particolare, si mostra che le 3-catene sono atomi irriducibili   dell'algebra CSG con celle chiuse e regolari. Inoltre, potrebbero essere   non convesse ed avere buchi. La cella esterna è il complemento della   loro unione. Qualsiasi modello geometrico dell'algebra booleana CSG   generata da questi cinque cubi è composto da un sottoinsieme di quei 25   atomi.","category":"page"},{"location":"ComplCatECelle.html#Complessi-di-catene-e-complessi-di-celle","page":"Complessi di catene e complessi di celle","title":"Complessi di catene e complessi di celle","text":"","category":"section"},{"location":"ComplCatECelle.html","page":"Complessi di catene e complessi di celle","title":"Complessi di catene e complessi di celle","text":"Un complesso è un insieme S con grado S = S _i  . Verranno   utilizzati due tipi di complessi diversi ma intrecciati, in particolare   complessi cellulari e complessi di catene. Le loro definizioni ed alcuni   concetti correlati vengono forniti in questa sezione. Le lettere   greche saranno usate per le celle di uno spazio di partizione e le   lettere romane per le catene di celle, codificate come numeri   interi con e senza segno o array sparsi di numeri interi con e senza   segno.","category":"page"},{"location":"AnalisiPrestazioni.html#Analisi-prestazioni","page":"Analisi delle prestazioni","title":"Analisi prestazioni","text":"","category":"section"},{"location":"AnalisiPrestazioni.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"In questa fase dell'evoluzione del nostro progetto abbiamo scelto di   focalizzarci sul miglioramento di due funzioni principali: frag faces e   merge vertices. Ai fini dell'ottimizzazione del progetto, ed eventuale   valutazione delle prestazioni, abbiamo preso spunto dal libro Julia   High Performance. Per quanto riguarda l'ottimizzazione con i Task si è   scelto di utilizzare le seguenti macro:","category":"page"},{"location":"AnalisiPrestazioni.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"@async: racchiude un Task, si occupa di far iniziare subito     l'attività racchiusa nel task procedendo con qualsiasi operazione     che segue la macro.\n@sync: racchiude un Task. Ha comportamento opposto a la macro     precedente, infatti aspetta che tutti i task parallelizzati     terminino prima di eseguire il proprio Task.\n@spawn: crea un Task e lo assegna ad un qualsiasi thread     disponibile. Il Task verrà eseguito quando si libera il thread a cui     è assegnato.\n@views: converte le operazione di taglio su un array di una data     espressione per poi dare come output una variabile di tipo View\n@simd: viene utilizzato nei cicli for al fine di dare maggior     libertà nella gestione del ciclo.\nThreads.@threads: questa macro è apposta davanti a un ciclo for     per indicare a Julia che il ciclo è una regione multi-thread.","category":"page"},{"location":"AnalisiPrestazioni.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"Per quanto riguarda la valutazione delle prestazioni:","category":"page"},{"location":"AnalisiPrestazioni.html","page":"Analisi delle prestazioni","title":"Analisi delle prestazioni","text":"@benchmark: valuta le prestazioni delle funzioni che racchiude,     chiamandola più volte ai fini di creare dei campioni per la     valutazione.\n@btime: simile a benchmark, ma con meno informazioni.Valuta le     prestazioni della funzione svariate volte al fine di ridurre il     rumore.\n@profile: esegue l'espressione a cui è assegnata collezionando     dei campioni periodicamente in modo tale da mostrare la gerarchia     delle funzioni ed il tempo di esecuzione di ogni riga.","category":"page"},{"location":"introduzione.html#Introduzione","page":"Introduzione","title":"Introduzione","text":"","category":"section"},{"location":"introduzione.html","page":"Introduzione","title":"Introduzione","text":"Il dominio dello schema di rappresentazione è attualmente limitato   all'Algebra Booleana dei poliedri PL, che possono essere disconnessi e/o   non-varianti. Gli elementi di questa algebra sono in corrispondenza   uno-ad-uno, biunivoca, con le 3-chains complexes, ossia i complessi di   catene di 3 dimensioni, usando le basi p-chains (p-celle, con p = 0  3) con cui sono connesse.\nData una qualsiasi raccolta di modelli di questo dominio, utilizzando   l'approccio di Paoluzzi, costruiamo la rappresentazione LAR della loro   disposizione in E^3, includendo il complesso di tre-catene con   delta_p operatori rappresentati da matrici sparse (si ricordi che le   matrici sparse sono matrici con molti elementi non significativi).   3-cells e le 3-chains elementari in LAR sono in corrispondenza   uno-ad-uno con gli atomi dell'Algebra Booleana dei CSG . Per cui ogni   solido 3D in questa algebra booleana può essere rappresentato sia da una   stringa di bit che ne indica la struttura in termini di atomi, cioè da   una 3-chains coerentemente orientata, sia dal suo 2-ciclo orientato al   limite.","category":"page"},{"location":"ciclieconfini.html#Cicli-e-confini","page":"Cicli e confini","title":"Cicli e confini","text":"","category":"section"},{"location":"ciclieconfini.html","page":"Cicli e confini","title":"Cicli e confini","text":"Due sottospazi altamente utili sono contenuti all'interno di ogni spazio   C_p delle catene: i sottospazi dei cicli e dei confini. \n\nDefinizione Catene, cicli e sottospazi di confine:\nUn p-ciclo è definito come una p-catena senza confine, per cui è un   elemento del kernel Z_p di delta_p (gli insiemi rossi della   figura). Un p-confine (p-boundary) è una p-catena che è il confine di   una (p+1)-catena, per cui è un elemento dell'immagine B_p di   delta_(p+1). L'insieme B_p è un sottoinsieme del kernel di   delta_p, poiché il confine del confine è vuoto.","category":"page"},{"location":"ciclieconfini.html","page":"Cicli e confini","title":"Cicli e confini","text":"(Image: image)","category":"page"},{"location":"ciclieconfini.html","page":"Cicli e confini","title":"Cicli e confini","text":"Proprietà le colonne della matrice delta_3^+ sono 2-cicli. L'algoritmo che implementeremo, cioè il topological-gift-wrapping   TGW in 3D, produce la matrice sparsa [delta_3^+], proprio   partendo dalla matrice sparsa [delta_2]. Più in generale, ogni   colonna delle matrici di confine, è un 2-ciclo.\nProprietà la somma delle righe di delta_3 è zero.","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"(Image: image)","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"***Magistrale in Ingnegneria Informatica***","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Calcolo parallelo e distribuito\nLAR - Topological gift wrapping in 3D\nGruppo 8a","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Nome Matricola E-mail Profilo Github\nEnnio Malvati 484998 enn.malvati@stud.uniroma3.it https://github.com/\\\nGianluca Di Lorenzo 583630 gia.dilorenzo1@stud.uniroma3.it https://github.com/\\\nRaffaele Scarano 576304 raf.scarano@stud.uniroma3.it https://github.com/","category":"page"},{"location":"arrangement.html#Introduzione","page":"Introduzione","title":"Introduzione","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Il dominio dello schema di rappresentazione è attualmente limitato   all'Algebra Booleana dei poliedri PL, che possono essere disconnessi e/o   non-varianti. Gli elementi di questa algebra sono in corrispondenza   uno-ad-uno, biunivoca, con le 3-chains complexes, ossia i complessi di   catene di 3 dimensioni, usando le basi p-chains (p-celle, con p = 0  3) con cui sono connesse.\nData una qualsiasi raccolta di modelli di questo dominio, utilizzando   l'approccio di Paoluzzi, costruiamo la rappresentazione LAR della loro   disposizione in E^3, includendo il complesso di tre-catene con   delta_p operatori rappresentati da matrici sparse (si ricordi che le   matrici sparse sono matrici con molti elementi non significativi).   3-cells e le 3-chains elementari in LAR sono in corrispondenza   uno-ad-uno con gli atomi dell'Algebra Booleana dei CSG . Per cui ogni   solido 3D in questa algebra booleana può essere rappresentato sia da una   stringa di bit che ne indica la struttura in termini di atomi, cioè da   una 3-chains coerentemente orientata, sia dal suo 2-ciclo orientato al   limite.","category":"page"},{"location":"arrangement.html#Stato-dell'arte","page":"Introduzione","title":"Stato dell'arte","text":"","category":"section"},{"location":"arrangement.html#Complessi-di-catene-e-complessi-di-celle","page":"Introduzione","title":"Complessi di catene e complessi di celle","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Un complesso è un insieme S con grado S = S _i  . Verranno   utilizzati due tipi di complessi diversi ma intrecciati, in particolare   complessi cellulari e complessi di catene. Le loro definizioni ed alcuni   concetti correlati vengono forniti in questa sezione. Le lettere   greche saranno usate per le celle di uno spazio di partizione e le   lettere romane per le catene di celle, codificate come numeri   interi con e senza segno o array sparsi di numeri interi con e senza   segno.","category":"page"},{"location":"arrangement.html#Complessi-di-celle","page":"Introduzione","title":"Complessi di celle","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Definizione d - Manifold : un manifold è uno spazio topologico   che localmente è simile ad un altro spazio topologico ben conosciuto, ad   esempio lo spazio euclideo n-dimensionale, ma che globalmente può avere   proprietà geometriche differenti, ad esempio può essere \"curvo\"   contrariamente allo spazio euclideo. Ogni punto di un manifold con d   dimensioni ha un vicino che è omeomorfo, cioè simile ma non   obbligatoriamente uguale del tutto, ad E^3, lo spazio euclidiano di   d-dimensioni.\n\nDefinizione Cella : una p-cella è un p-manifold con   confini 0 leq p leq d i quali sono lineari a tratti, connessi,   possibilmente non convessi e non contrattabili, non si storcono. Questa   definizione si riferisce ai complessi cellulari di questo lavoro e nella   nostra rappresentazione ci possono essere celle con buchi interni.\nAvremo a che fare con celle Piecewise-Linear (PL) (lineari a tratti)   rispettivamente di dimensione 0, 1, 2 e 3. Va notato che le 2-celle e   3-celle possono contenere dei fori (buchi), pur rimanendo collegati. In   altre parole, le celle sono poliedri, cioè segmenti, poligoni e poliedri   incorporati in uno spazio bi o tridimensionale.\n\nDefinizione complesso cellulare: un p-complesso cellulare è un   insieme finito di celle che hanno al massimo dimensione p, insieme   alle loro facce r-dimensionali dei bordi con 0 leq r leq p. Una   faccia è un elemento del confine lineare a tratti della cella, il quale   soddisfa le condizioni di compatibilità di confine, che seguono:","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Due p-celle sono boundary-compatible quando i loro punti di   intersezione contengono le stesse r-facce.\n\nUn complesso cellulare di dimensione p è definito regolare quando   ogni r-cella, con 0\\leq r\\leqp , è una faccia di una p-cella\n\nDefinizione Skeleton: Un s-skeleton di un p-complesso Lambda_p,   con s leq p, è l'insieme Lambda_s di tutte le r-celle di Lambda_p. Ogni scheletro di un complesso regolare è un sottocomplesso regolare.\n\nDefinizione Rappresentazione Geometrica: La rappresentazione   algebrica lineare (LAR) ha introdotto l'uso di array binari sparsi per   calcolare e rappresentare una topologia algebrica di complessi   cellulari, ovvero spazi lineari di catene e operatori di (co)confine   lineari. (Quindi è una mappatura della disposizione geometrica con   matrici/array sparsi binari).\n\nDefinizione Spazio di supporto: Lo spazio di supporto   |Lambda| di un complesso cellulare è l'insieme dei punti dell'unione   delle proprie celle.\nUna p-catena può essere vista, forzando il linguaggio, come   una collezione di p-celle.","category":"page"},{"location":"arrangement.html#Catene-e-Disposizioni","page":"Introduzione","title":"Catene e Disposizioni","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"La parola arrangment è usata nella geometria combinatoria e   computazionale, ma anche nella topologia, come sinonimo di partizione   spaziale.\n\nDefinizione Space Arrangement: Data una collezione finita S di   oggetti geometrici in E^d la disposizione A(S) è la decomposizione   di E^d in celle connesse di dimensione 0 1d indotte da S.   Siamo interessati alla partizione dello spazio euclideo indotta da una   collezione di complessi cellulari PL.\nData una collezione S di oggetti geometrici, un nuovo metodo per   calcolare la topologia della loro disposizione spaziale consiste nel   valutare A(S) come complesso di catene C.\nEsempio di 3D arrangment\n","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"(Image: image) (Image: image)","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Nelle figure si mostra la disposizione A(S) generata dalla collezione   S fatta dalle trenta facce 2D di 5 cubi che si intersecano   randomicamente. Ogni cella 3D in A(S) è generata da una colonna   della matrice sparsa della mappa di confine confine delta_3 con   valori in (01-1). Nella figura a sinistra si nota la collezione S di   5 cubi randomici in E^3, mentre quella di destra mostra le 3-celle   generate in E^3 dalla disposizione A(S), (non in scala, e   opportunamente ruotate per mostrare meglio la loro forma complessa). Si   noti che alcune celle contengono buchi. Le colonne di delta_3 sono 2-cicli, cioè catene chiuse in C2. In   particolare, si mostra che le 3-catene sono atomi irriducibili   dell'algebra CSG con celle chiuse e regolari. Inoltre, potrebbero essere   non convesse ed avere buchi. La cella esterna è il complemento della   loro unione. Qualsiasi modello geometrico dell'algebra booleana CSG   generata da questi cinque cubi è composto da un sottoinsieme di quei 25   atomi.","category":"page"},{"location":"arrangement.html#Cicli-e-confini","page":"Introduzione","title":"Cicli e confini","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Due sottospazi altamente utili sono contenuti all'interno di ogni spazio   C_p delle catene: i sottospazi dei cicli e dei confini. \n\nDefinizione Catene, cicli e sottospazi di confine:\nUn p-ciclo è definito come una p-catena senza confine, per cui è un   elemento del kernel Z_p di delta_p (gli insiemi rossi della   figura). Un p-confine (p-boundary) è una p-catena che è il confine di   una (p+1)-catena, per cui è un elemento dell'immagine B_p di   delta_(p+1). L'insieme B_p è un sottoinsieme del kernel di   delta_p, poiché il confine del confine è vuoto.","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"(Image: image)","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Proprietà le colonne della matrice delta_3^+ sono 2-cicli. L'algoritmo che implementeremo, cioè il topological-gift-wrapping   TGW in 3D, produce la matrice sparsa [delta_3^+], proprio   partendo dalla matrice sparsa [delta_2]. Più in generale, ogni   colonna delle matrici di confine, è un 2-ciclo.\nProprietà la somma delle righe di delta_3 è zero.","category":"page"},{"location":"arrangement.html#Calcolo-dei-confini","page":"Introduzione","title":"Calcolo dei confini","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Nella maggior parte dei casi, l'ambiente di calcolo geometrico di   destinazione è in grado di visualizzare, più in generale di gestire, un   modello solido utilizzando solamente una rappresentazione dei   confini/bordi, tipicamente usando una triangolazione. È facile ottenere   una tale rappresentazione moltiplicando la matrice dell'operatore   3-boundary (bordi a tre dimensioni) delta_3  C_3 longmapsto   C_2^circlearrowleft per il vettore di coordinate C3 nello spazio   dell'espressione solida, calcolato come termine binario nel nostro   insieme algebrico[1].\nUna volta ottenuta in questo modo la coordinata designata del vettore di   bordo dell'oggetto solido, cioè la 2-catena formata dalle sue 2-celle   orientate (le facce), queste devono essere raccolte da colonne in una   \"matrice facciale\" sparsa e tradotta nella corrispondente matrice di   1-cicli orientati di spigoli/edge, per moltiplicazioni destre di   [delta_2] per la matrice delle facce. I poligoni di   confine/boundary generati (corrispondenti alle colonne della matrice   prodotto sparsa) saranno normalmente triangolizzati e infine   renderizzati dall'hardware grafico o esportati in formati di file   grafici standard o qualsiasi altro formato geometrico necessario per   l'applicazione prevista.\n\nDefinizione Complessi Geometrici LAR: è utile ricordare che per   mostrare una triangolarizzazione di facce di bordo nella loro propria   posizione nello spazio, tutte le informazioni geometriche e topologiche   necessarie sono contenute all'interno di evaluatedLAR o in   GeometricComplex (GC), data la coppia :","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"mu  C_0 longmapsto E^3 (delta_2delta_1 delta_0)  \nequiv V (CF FE EV)","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"dove V è di tipo Matrix-Real con tre righe e colonne pari alla   cardinalità di C_0 ed inoltre (CF, FE, EV) sono matrici sparse di   co-bordi (coboundary). Le coppie ordinate di lettere da V, E, F, C,   corrispondono alla sequenza coboundary che segue: Vertici → Bordo (edge)   → Facce → Celle espresso attraverso l'ordine sinistrorso Colonna → Riga   di mappe matriciali di operatori.\n\nMemorizzazione di Complessi Geometrici Lar: La topologia di un   3-complesso LAR è completamente rappresentata dagli operatori   (delta_2,delta_1, delta_0) , cioè dagli array sparsi (CF FE EV), fornendo le incidenze tra vertici, bordi e facce, sia per b-reps  (rappresentazione geometrica dai bordi) che per rappresentazioni cellulari.","category":"page"},{"location":"arrangement.html#Algoritmo-Topological-Gift-Wrapping-TGW","page":"Introduzione","title":"Algoritmo Topological Gift Wrapping - TGW","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"L'algoritmo TGW è descritto in questa sezione, generalizzandolo per lo   spazio d-dimensionale. L'input è la matrice sparsa [delta_d-1],   l'output è la matrice [delta_d^+], dalla d-catena al (d-1)-ciclo   orientato.","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"(Image: image)","category":"page"},{"location":"arrangement.html#Funzioni-del-progetto","page":"Introduzione","title":"Funzioni del progetto","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Dopo un'attenta analisi del repository   https://github.com/cvdlab/LinearAlgebraicRepresentation.jl, abbiamo   definito il grafo delle dipendenze relativo al progetto a noi assegnato.   Il risultato della nostra analisi è la seguente:","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"(Image: image)","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Si definiranno ora le funzionalità principali della repository utili ai   fini dell'algoritmo TGW 3D.","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"La funzione spatial arrangment si occupa di partizionare i complessi   cellulari, presi in input, con scheletro di dimensione 2 in 3D. Ne segue   che un complesso cellulare è partizionato quando l'intersezione di   ogni possibile coppia del complesso risulta vuota e l'unione di   tutte le celle è tutto lo spazio euclideo. L'output della funzione   consiste nella partizione complessa rappresentata da una lista di   vertici V e di una catena di bordi EV, FE, CF.\n\nspatial arrangment 1: questa funzione frammenta le facce delle   figure ai fini dell'utilizzo del arrangment planare. A tal fine usa come   funzioni di supporto frag face e merge vertices. Saranno proprio   questi i metodi che andremmo ad ottimizare.\n1) frag face: effettua la trasformazione in 2D delle facce fornite in      input tramite il parametro sigma ed infine ogni faccia di questo      parametro sigma si interseca con le facce in sp index.\n2) merge vertices: effettua il merge delle facce vicine, vertici e      lati.\n3) spatial arrangment 2: ricostruisce le facce dei poligoni permettendo      il wrapping in 3D.","category":"page"},{"location":"arrangement.html#Analisi-prestazioni","page":"Introduzione","title":"Analisi prestazioni","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"In questa fase dell'evoluzione del nostro progetto abbiamo scelto di   focalizzarci sul miglioramento di due funzioni principali: frag faces e   merge vertices. Ai fini dell'ottimizzazione del progetto, ed eventuale   valutazione delle prestazioni, abbiamo preso spunto dal libro Julia   High Performance. Per quanto riguarda l'ottimizzazione con i Task si è   scelto di utilizzare le seguenti macro:","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"\\@async: racchiude un Task, si occupa di far iniziare subito     l'attività racchiusa nel task procedendo con qualsiasi operazione     che segue la macro.\n\\@sync: racchiude un Task. Ha comportamento opposto a la macro     precedente, infatti aspetta che tutti i task parallelizzati     terminino prima di eseguire il proprio Task.\n\\@spawn: crea un Task e lo assegna ad un qualsiasi thread     disponibile. Il Task verrà eseguito quando si libera il thread a cui     è assegnato.\n\\@views: converte le operazione di taglio su un array di una data     espressione per poi dare come output una variabile di tipo View\n\\@simd: viene utilizzato nei cicli for al fine di dare maggior     libertà nella gestione del ciclo.\nThreads.@threads: questa macro è apposta davanti a un ciclo for     per indicare a Julia che il ciclo è una regione multi-thread.","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Per quanto riguarda la valutazione delle prestazioni:","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"\\@benchmark: valuta le prestazioni delle funzioni che racchiude,     chiamandola più volte ai fini di creare dei campioni per la     valutazione.\n\\@btime: simile a benchmark, ma con meno informazioni.Valuta le     prestazioni della funzione svariate volte al fine di ridurre il     rumore.\n\\@profile: esegue l'espressione a cui è assegnata collezionando     dei campioni periodicamente in modo tale da mostrare la gerarchia     delle funzioni ed il tempo di esecuzione di ogni riga.","category":"page"},{"location":"arrangement.html#Ottimizzazione","page":"Introduzione","title":"Ottimizzazione","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"Nel notebook spatial arrangment 1 sono stati messe tutte le   ottimizzazioni dovute all'analisi del codice iniziale di LAR. Siamo   partiti valutando le prestazioni della singola funzione spatial   arrangment 1 con relativa tipicizzazione. Per la valutazione delle   prestazioni si è utilizzata la macro @btime, metre per la   tipicizzazione abbiamo usato la macro @code warntype. Quest'ultima   macro genera una rappresentazione del codice che può essere utile per   trovare espressioni che determinano l'incertezza del tipo. Dopo   quest'analisi preliminare abbiamo subito migliorato un minimo i tipi di   questa funzione ottenendo già un lieve miglioramento. Una volta superata   questa fase abbiamo scelto di proseguire con l'ottimizzazione di due   funzioni che sono utilizzate all'interno di spatial arrangment 1, che   sono: frag faces e merge vertices. Oltre a valutare la   tipicizzazione delle due funzioni abbiamo inserito all'interno una   parallelizzazione del codice utilizzando due macro: Threads.@threads e   @async. Una volta migliorate le due funzioni si è andato a verificare   se effettivamente, dopo le modifiche da noi apportate, ci sia stato un   miglioramento della funzione spatial arrangment 1. Si è cercato di   testare le funzioni su tutti e tre i nostri calcolatori (due Mac ed un   Windows), i quali avevano architetture fisiche differenti. Nel computer   con Windows, inoltre, si è utilizzata una virtualizzazione del sistema   Linux. Come risultato abbiamo ottenuto una effettiva ottimizzazione su   un pc Mac e il Linux virtualizzato, ma in uno dei due Mac le prestazioni   sono peggiorate. Si pensa che questo problema sia dovuto all'overhead   della gestione dei Task, ma non ne abbiamo l'assoluta certezza. Ad ogni   modo, al fine della valutazione delle nostre modifiche al codice si   rimanda notebook spatial arrangment.","category":"page"},{"location":"arrangement.html#References","page":"Introduzione","title":"References","text":"","category":"section"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"[1] Alberto Paoluzzi,Vadim Shapiro, Antonio DiCarlo, Giorgio Scorzelli and Elia Onofri *Finite Algebras for Solid Modeling using Julia's Sparse  \nArrays*. \n[2] Repository del *Computational Visual Design Lab di Roma Tre*  \n<https://github.com/cvdlab/LinearAlgebraicRepresentation.jl> \n[3] Il nostro repository <https://github.com/not-Karot/LinearAlgebraicRepresentation.jl>\n[4] Sengupta, Avik.*Julia High Performance : Optimizations, Distributed Computing, Multithreading, and GPU Programming with Julia 1. 0 and Beyond, 2nd Edition. Birmingham : Packt Publishing, Limited, ©2019*.  ","category":"page"},{"location":"arrangement.html","page":"Introduzione","title":"Introduzione","text":"[1]: Si ricordi che con la notazione C si intende il complesso di catene nel campo binario 1,0 e con C^circlearrowleft si indica il complesso di catene orientato all'interno del campo ternario 0,1,-1 in modo da avere confini orientati. Quindi le matrici di confine generate da TGW sono mappe C_3 longmapsto C_2^circlearrowleft.","category":"page"},{"location":"index.html#TopologicalGiftWrapping8A.jl","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A.jl","text":"","category":"section"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"TopologicalGiftWrapping8A.jl è un modulo Julia sviluppato per il corso di Calcolo Parallelo e Distribuito svolto da:","category":"page"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"Nome Matricola E-mail Profilo Github\nEnnio Malvati 484998 enn.malvati@stud.uniroma3.it https://github.com/Ennio28\nGianluca Di Lorenzo 583630 gia.dilorenzo1@stud.uniroma3.it https://github.com/CostaG25\nRaffaele Scarano 576304 raf.scarano@stud.uniroma3.it https://github.com/not-Karot","category":"page"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"L'obiettivo del progetto è quello di ottimizzare l'esecuzione dell'algoritmo Topological Gift Wrapping 3D della libreria LinearAlgebraicRepresentation.jl.","category":"page"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"Link al repository GitHub: https://github.com/not-Karot/TopologicalGiftWrapping8A","category":"page"},{"location":"index.html#Dipendenze","page":"TopologicalGiftWrapping8A","title":"Dipendenze","text":"","category":"section"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"TopologicalGiftWrapping8A.jl ha alcune dipendenze Julia:","category":"page"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"LinearAlgebraicRepresentation\nBenchmarkTools\nViewerGL\nDistributed\nIntervalTrees\nLinearAlgebra\nNearestNeighbors\nSparseArrays\nTriangle\nTriangulate","category":"page"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"Link ai notebook:","category":"page"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"frag_face_parallelized.ipynb: https://github.com/not-Karot/TopologicalGiftWrapping8A/blob/main/notebooks/fragfaceparallelized.ipynb\nmerge_vertices_parallelized.ipynb: https://github.com/not-Karot/TopologicalGiftWrapping8A/blob/main/notebooks/mergeverticesparallelized.ipynb\nspatial_arrangement_1.ipynb : https://github.com/not-Karot/TopologicalGiftWrapping8A/blob/main/notebooks/spatialarrangement1.ipynb\nspatial_arrangement.ipynb: https://github.com/not-Karot/TopologicalGiftWrapping8A/blob/main/notebooks/spatial_arrangement.ipynb","category":"page"},{"location":"index.html#Indice","page":"TopologicalGiftWrapping8A","title":"Indice","text":"","category":"section"},{"location":"index.html","page":"TopologicalGiftWrapping8A","title":"TopologicalGiftWrapping8A","text":"Pages = [\"index.md\", \"introduzione.md\", \"ComplCatECelle.md\", \"ComplCelle.md\", \"CatEDisp.md\", \"ciclieconfini.md\",\"CalcoloConfini.md\",\n        \"AlgTGW.md\",\"funzioni.md\",\"docs_spatial_arrangement.md\", \"AnalisiPrestazioni.md\", \"analisi.md\",\"riferimenti.md\"]\nDepth = 3","category":"page"},{"location":"riferimenti.html#References","page":"Riferimenti","title":"References","text":"","category":"section"},{"location":"riferimenti.html","page":"Riferimenti","title":"Riferimenti","text":"[1] Alberto Paoluzzi,Vadim Shapiro, Antonio DiCarlo, Giorgio Scorzelli and Elia Onofri *Finite Algebras for Solid Modeling using Julia's Sparse  \nArrays*. \n[2] Repository del *Computational Visual Design Lab di Roma Tre*  \n<https://github.com/cvdlab/LinearAlgebraicRepresentation.jl> \n[3] Il nostro repository <https://github.com/not-Karot/TopologicalGiftWrapping8A>\n[4] Sengupta, Avik.*Julia High Performance : Optimizations, Distributed Computing, Multithreading, and GPU Programming with Julia 1. 0 and Beyond, 2nd Edition. Birmingham : Packt Publishing, Limited, ©2019*.  ","category":"page"}]
}
